/**
 * Evaluate [PYTHONCLASS] with angular distribution given
 * by user. 
 * 
 * This code was written as part of the DANSE project
 *  http://danse.us/trac/sans/
 *
 * WARNING: THIS FILE WAS GENERATED BY IGORGENERATOR.PY
 *          DO NOT MODIFY THIS FILE, MODIFY [INCLUDE_FILE]
 *          AND RE-RUN THE GENERATOR SCRIPT
 *   
 *  @copyright 2007: University of Tennessee, for the DANSE project
 *
 */

#include "c_disperser.h"
#include "danse.h"
#include <math.h>

/**
 * Evaluate model for given angular distributions in theta and phi.
 * 
 * Angles are in radian.
 * 
 * See [C_FILE_NAME] for more information about the model parameters.
 * 
 * @param dp: model parameters
 * @param phi_values: vector of phi_values
 * @param phi_weights: vector of weights for each entry in phi_values
 * @param n_phi: length of phi_values and phi_weights vectors
 * @param theta_values: vector of theta values
 * @param theta_weights: vector of weights for each entry in theta_values
 * @param n_theta: length of theta_Values and theta_weights vectors
 * @param q: q-value to evaluate the model at
 * @param phi_q: angle between the q-vector and the q_x axis
 * @return: scattering intensity
 * 
[PARS_LIST]
 * 
 */
double [MODEL_NAME]_Weights(double dp[], double *phi_values, double *phi_weights, int n_phi, 
								double *theta_values, double *theta_weights, int n_theta, 
								double q, double phi_q) {
	// Copy of parameters
	double pars[[NPARS]];
	// Parameter index for theta
	int theta_index = [THETA_INDEX];
	// Parameter index for phi
	int phi_index   = [PHI_INDEX];
	int i, i_theta;
	double sum, norm;
	
	// Copy parameters because they will be modified
	for(i=0; i<[NPARS]; i++) {
		pars[i] = dp[i];
	}

	if (n_theta == 0) {
		return weight_dispersion( &disperse_[MODEL_NAME]_analytical_2D,
				phi_values, phi_weights, n_phi, phi_index, pars, q, phi_q );
	} else {
		sum = 0.0;
		norm = 0.0;
		
		for(i_theta=0; i_theta<n_theta; i_theta++) {
			// Assign new theta value
			pars[theta_index] = theta_values[i_theta];
			// Evaluate the function, weight by sin(theta) 
			sum += sin(theta_values[i_theta]) * theta_weights[i_theta] * 
					weight_dispersion( &disperse_[MODEL_NAME]_analytical_2D,
					phi_values, phi_weights, n_phi, phi_index, pars, q, phi_q );
			// Keep track of normalization
			norm += theta_weights[i_theta];
		}
		
		// Protect against null weight vector
		if(norm > 0) {
			return sum/norm;
		}
	}
	return 0.0;
}


